{"is404":false,"staticData":{"642666715":"{\"parsedFrontmatter\":{\"title\":\"Fixing Dan and Ayd覺n's Pyright Error\",\"img_url\":\"images/pyright.webp\",\"img_alt\":\"The Pyright Logo on Fire\",\"date\":\"2022-08-04\",\"seo_description\":\"How learning about Variance helped me fix a Pyright error.\",\"summary\":\"How learning about Variance helped me fix a Pyright error.\",\"tags\":[\"rust\",\"variance\",\"java\",\"javascript\",\"typescript\"],\"hidden\":false},\"withoutFrontmatter\":\"\\n![Pyright](images/pyright.webp)\\n\\n# Fixing Dan and Ayd覺n's Pyright Error\\n\\n_Note: If you've never heard of Pylance/Pyright don't worry, it's just the TypeScript-ification of Python._\\n_If that doesn't mean anything to you, this might not be the blog post for you._\\n\\n## Backstory\\n\\nA few months ago, my friends Dan and Ayd覺n showed me this strange bug in the project they were working on.\\n\\nThey were using Python with type annotations and Microsoft's Pylance/Pyright type checker - here's (roughly) the problematic snippet:\\n\\n```python\\ndef send(data: Dict[str, str | None]):\\n    # ...\\n    \\nperson: Dict[str, str] = { \\\"name\\\": \\\"Guido\\\", \\\"dob\\\": \\\"1956-01-31\\\" }\\n\\nsend(person)\\n```\\n\\nWhen they ran the type checker on this code, they were presented with the following error:\\n\\n```python\\nerror: Argument of type \\\"dict[str, str]\\\" cannot be assigned to\\nparameter \\\"data\\\" of type \\\"Dict[str, str | None]\\\" in function \\\"send\\\"\\n  TypeVar \\\"_VT@dict\\\" is invariant\\n    Type \\\"str\\\" cannot be assigned to type \\\"str | None\\\"\\n      Type cannot be assigned to type \\\"None\\\" (reportGeneralTypeIssues)\\n```\\n\\nThis is the compiler's way of saying *__\\\"you can't pass a value of type `Dict[str, str]` into a function that expects `Dict[str, str | None]`\\\"__*\\n\\nThis seems wrong - surely any function that can handle a `Dict[str, str | None]` can handle a `Dict[str, str]` - in fact, a `Dict[str, str]` *is* a `Dict[str, str | None]`!\\n\\nSure enough, we can check that a `str` is a `str | None`:\\n\\n```python\\nname1: str = \\\"Guido\\\"\\nname2: str | None = name1\\n```\\n\\nPyright has no problems at all with this code.\\n\\nSurely (to be overly mathematical) if _`x` is a subtype of `y`_ then  _`Dict[a, x]` is a subtype of `Dict[a, y]`_.\\n\\nVery puzzling...\\n\\n## Rust for Rustaceans\\n\\nCrushingly, I could never fix Dan and Ayd覺n's type error. I just shrugged and said Microsoft probably never bothered to implement that rule for `Dict`s.\\n\\nThen, three months later, I was reading (the fantastic) _Rust for Rustaceans_ (a book about the Rust programming language). It introduced me to the concept of **Variance**, an idea I'd never heard of before.\\n\\n_(Maybe if I read the full Pyright error the first time I'd've noticed the \\\"`TypeVar \\\"_VT@dict\\\" is invariant`\\\" warning but alas)._\\n\\nIt turns out **Variance** was the culprit all along - but first, let me introduce it with a tour of some popular programming languages.\\n\\n## Insanely Liberal Variance in TypeScript\\n\\nTypeScript has never sold itself as a fully type-safe solution, more of a glorified linter.\\nIt helps you catch **some** errors before you see them at runtime.\\n\\n_Consider the following (valid & compilable) TypeScript program._\\\"\\n\\n```ts\\ntype Status = \\\"OK\\\" | \\\"PENDING\\\" | \\\"INVALID\\\"\\n\\ntype ValidStatus = \\\"OK\\\" | \\\"PENDING\\\"\\n\\nconst orders: ValidStatus[] = [\\\"OK\\\", \\\"OK\\\", \\\"PENDING\\\"]\\n\\nconst add = (orders: Status[]) => {\\n    orders.push(\\\"INVALID\\\");\\n}\\n\\nadd(orders)\\n```\\n\\nNow orders has an invalid order in it - but it's type (`ValidStatus[]`) would tell you that's impossible!\\n\\nThe issue here is that we are *mutating the list* inside the add function.\\n\\nIf we treat `orders` as a `Status[]` in one place, and refer to it as a `ValidStatus[]` in another, we can cause all kinds of problems.\\n\\nThis can be avoided with the following, **immutable** version of the `add` function:\\n\\n```ts\\n// ...\\n\\nconst add = (orders: readonly Status[]): readonly Status[] => {\\n    return [ ...orders,  \\\"INVALID\\\" ];\\n}\\n\\norders = add(orders)\\n```\\n\\nHowever:\\n- It's not idiomatic JavaScript\\n- It's far less efficient than using `push`\\n\\nIt's easy to get caught up evangelising immutable JavaScript as the solutions to these kinds of problems,\\nbut the performance impact can't be understated [(see here for an example)](/js-spread-operator).\\n\\n## Facist Variance Rules in Java\\n\\nJava's type system is stronger than TypeScript's, so let's recreate a similar example and see how it fares:\\n\\nWe can defined the ValidStatus __*is-a*__ Status relation:\\n```java\\nclass Status {}\\n\\nclass ValidStatus extends Status {}\\n```\\n\\n```java\\nvoid add(List<Status> orders) {\\n    // ...\\n}\\n\\nList<ValidStatus> orders;\\n    \\nadd(orders);\\n```\\n\\nJava gives the following error:\\n\\n```java\\nerror: incompatible types: List<ValidStatus> cannot be converted to List<Status>\\n```\\n\\nPretty harsh! Java won't let us pass a `List<ValidStatus>` into a `List<Status>` function, for fear we may mutate it.\\n\\nI suppose that's one way of solving the problem?\\n\\n## Fianlly, Understanding Variance in Pyright\\n\\nWith all of this context, let's look back at our original problem:\\n\\n```python\\ndef send(data: Dict[str, str | None]):\\n    # ...\\n    \\nperson: Dict[str, str] = { \\\"name\\\": \\\"Guido\\\", \\\"dob\\\": \\\"1956-01-31\\\" }\\n\\nsend(person)\\n```\\n\\nI finally see why Pyright is worried about this code.\\n\\nHow does it know we're not going to change the `_person_` dictionary inside the `_send_` function?\\n\\nWe can't fault Pyright here, it's being as strict as it should be.\\nBut still, the type checker is holding us back. Maybe type systems are rubbish after all?\\n\\n## Rust Lets Me Down\\n\\nDespite **Rust**'s role in helping me understand this concept, it takes a Java-eqsue approach to subtyping inside lists.\\n\\nI was gutted to discover this - I felt Rust had all the right pieces to handle this perfectly but fall at the final hurdle.\\n\\nIt even differentiates between mutable and immutable references in the type system, so it could easily allow subtyping `T` in `&dyn Vec<T>` and forbid it for `&dyn mut Vec<T>`.\\n\\nAs described in the [Rustomicron](https://doc.rust-lang.org/nomicon/subtyping.html#variance), it's actually Rust's choice to abstain from object-orientation that makes this impossible. `&dyn T` isn't really a subtype of `&dyn U`, it's more \\\"castable\\\" to it.\\n\\n_(I still don't really see why we can't just cast Functors in the same way, if anyone does please let me know)_\\n\\n## Scala Saves the Day\\n\\nIf you're anything like me, at this stage you might be thinking, _\\\"Does **any** semi-popular modern programming language have robust variance rules?\\\"_\\n\\nScala does!\\n\\nScala is basically just a \\\"funtional Java\\\", and so it has first class support for both immutable data structures and subtyping.\\n\\nThis makes it perfect for our variance problem!\\n\\nIn Scala there are lots of different types of list, two examples are the immutable `List` and it's mutable brother `ListBuffer`.\\n\\nAgain we define the `ValidStatus` __*is-a*__ `Status` relation:\\n\\n```scala\\nclass Status {}\\n\\nclass ValidStatus extends Status {}\\n```\\n\\nSo `List` lets us do this:\\n\\n```scala\\ndef add(orders: List[Status]) {\\n    // we can't change list here, just look at it\\n}\\n\\nval orders = List[ValidStatus]()\\nadd(orders)\\n```\\n\\nWhile trying the same thing with `ListBuffer`...\\n\\n```java\\ndef add(orders: ListBuffer[Status]) {\\n    // we can change orders here!\\n    orders += new Status()\\n}\\n\\nval orders = ListBuffer[ValidStatus]()\\nadd(orders)\\n```\\nGives us the following error:\\n```java\\nerror: type mismatch;\\n found   : scala.collection.mutable.ListBuffer[ValidStatus]\\n required: scala.collection.mutable.ListBuffer[Status]\\nNote: ValidStatus <: Status, but class ListBuffer is invariant in type A.\\n```\\n\\nIt even describes ListBuffer as `invariant`, making Scala the winner in today's arbitrary programming language contest.\\n\\nThanks for reading!\\n\"}","3307685479":"[\"content/blog/variance.md\"]"},"path":"variance"}