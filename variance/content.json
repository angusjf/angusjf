{"is404":false,"staticData":{"642666715":"{\"parsedFrontmatter\":{\"title\":\"Fixing Dan and Aydın's Pyright Error\",\"img_url\":\"images/elm.webp\",\"img_alt\":\"The Elm logo\",\"date\":\"2021-10-25\",\"seo_description\":\"Fixing Dan and Aydın's Pyright Error\",\"summary\":\"How Elm takes a novel approach to creating frontend applications, and what React developers can learn from it. Originally written for the [Theodo Blog](https://blog.theodo.com/2021/10/intro-to-elm-for-react-devs/), published in the [React Newsletter](https://reactnewsletter.com/issues/289).\",\"tags\":[\"elm\",\"react\",\"functional\",\"javascript\",\"typescript\"],\"hidden\":true},\"withoutFrontmatter\":\"# Fixing Dan and Aydın's Pyright Error\\n\\n## Backstory\\n\\nA few months ago, my friends Dan and Aydın showed me this strange bug in the project they were working on.\\n\\nThey were using Python with type annotations and Microsoft's Pylance/Pycheck type checker - here's the problematic snippet:\\n\\n```py\\nTODO\\n```\\n\\nWhen they ran the type checker on this code, they were presented with the following error:\\n\\n```py\\nTODO\\n```\\n\\nThis is the compiler's way of saying *__\\\"you can't pass a value of type `Dict[str, str]` into a function that expects `Dict[str, str | None]`\\\"__*\\n\\nThis seems wrong - surely any function that can handle a `Dict[str, str | None]` can handle a `Dict[str, str]` - in fact, a `Dict[str, str]` *is* a `Dict[str, str | None]`!\\n\\nSure enough, we can check that a `str` is a `str | None`:\\n\\n```py\\nname1: str = \\\"guido\\\"\\nname2: str | None = name1\\n```\\n\\nPycheck has no problems at all with this code.\\n\\nSurely (to be overly mathematical) if _`x` is a subtype of `y`_ then  _`Dict[a, x]` is a subtype of `Dict[a, y]`_.\\n\\nVery puzzling...\\n\\n## Rust for Rustaceans\\n\\nCrushingly, I could never fix Dan and Aydın's type error. I just shrugged and said Microsoft probably never bothered to implement that rule.\\n\\nThen, three months later, I was reading (the fantastic) _Rust for Rustaceans_ (a book about the Rust programming language). On page ** they mention the concept of variance, an idea I'd never heard of before.\\n\\nIt turns out **variance** was the culprit all along - but first, let me introduce it with a tour of some popular programming languages.\\n\\n## Variance in TypeScript\\n\\nTypeScript has never sold itself as a fully type-safe solution, more of a glorified linter.\\nIt helps you catch **some** errors before you see them at runtime.\\n\\n_Consider the following (valid & compilable) TypeScript program._\\n\\n```ts\\ntype Status = \\\"OK\\\" | \\\"PENDING\\\" | \\\"INVALID\\\"\\n\\ntype ValidStatus = \\\"OK\\\" | \\\"PENDING\\\"\\n\\nconst orders: ValidStatus[] = [\\\"OK\\\", \\\"OK\\\", \\\"PENDING\\\"]\\n\\nconst add = (orders: Status[]) => {\\n    orders.push(\\\"INVALID\\\");\\n}\\n\\nadd(orders)\\n```\\n\\nNow orders has an invalid order in it - but it's type (`ValidStatus[]`) would tell you that's impossible!\\n\\nThe issue here is that we are *mutating the list* inside the add function.\\n\\nIf we treat `orders` as a `Status[]` in one place, and refer to it as a `ValidStatus[]` in another, we can cause all kinds of problems.\\n\\nThis can be avoided with the following, **immutable** version of the `add` function:\\n\\n```ts\\ntodo\\n```\\n\\nHowever:\\n- It's not ideomatic JavaScript\\n- It's far less efficient than using `push`\\n\\nIt's easy to get caught up evangilising immutable JavaScript as the solutions to these kinds of problems,\\nbut the performance impact can't be understated (see footnote 1 for an example).\\n\\n## Variance in Java\\n\\nJava's type system is stronger than TypeScript's, so let's recreate a similar example and see how it fares:\\n\\n```java\\nimport java.util.List;\\n\\nclass Status {}\\n\\nclass ValidStatus extends Status {}\\n\\nclass Main {\\n    public static void main(String[] args) {\\n        List<ValidStatus> orders;\\n        \\n        add(orders);\\n    }\\n    \\n    static void add(List<Status> orders) {\\n        // ...\\n    }\\n}\\n```\\n\\nJava gives the following error:\\n\\n```\\n\\n```\\n\\nPretty harsh! Java won't let us pass a `List<ValidStatus>` into a `List<Status>`, for fear we may mutate it.\\n\\nI suppose that's one way of solving the problem?\\n\\n## Variance in Rust\\n\\nRust's type system is the only one I've seen that **solves this problem properly**, that is to say it allows valid functions an d disallows dangerous ones.\\n\\n```rs\\nlet x: u32 = 1\\n```\\n\\nTo finally introduce the term, we can describe List\\n\\n## Variance in Pyright\\n\\nWith all of this context, let's look back at our original problem:\\n\\n```py\\n\\n```\\n\\nI finally see why Pyright is worried about this code.\\n\\nHow does it know we're not going to change the `***` dictionary inside the `***999*` function?\\n\\nHere Pyright is being just as strict as Java (although a little more cyptic).\\n\\n\\n\"}","3307685479":"[\"content/blog/variance.md\"]"},"path":"variance"}