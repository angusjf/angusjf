<!DOCTYPE html>
  <html lang="en">
  <head>
    <link rel="stylesheet" href="/style.css">
    
    <link rel="preload" href="/elm.js" as="script">
    <link rel="modulepreload" href="/index.js">
    
    <script defer="defer" src="/elm.js" type="text/javascript"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <script type="module">
import userInit from"/index.js";
let prefetchedPages=[window.location.pathname],initialLocationHash=document.location.hash.replace(/^#/,"");function loadContentAndInitializeApp(){let a=window.location.pathname.replace(/(w)$/,"$1/");a.endsWith("/")||(a+="/");const b=Elm.TemplateModulesBeta.init({flags:{secrets:null,baseUrl:document.baseURI,isPrerendering:!1,isDevServer:!1,isElmDebugMode:!1,contentJson:JSON.parse(document.getElementById("__ELM_PAGES_DATA__").innerHTML),userFlags:userInit.flags()}});return b.ports.toJsPort.subscribe(()=>{loadNamedAnchor()}),b}function loadNamedAnchor(){if(""!==initialLocationHash){const a=document.querySelector(`[name=${initialLocationHash}]`);a&&a.scrollIntoView()}}function prefetchIfNeeded(a){if(a.host===window.location.host&&!prefetchedPages.includes(a.pathname)){prefetchedPages.push(a.pathname),console.log("Preloading...",a.pathname);const b=document.createElement("link");b.setAttribute("as","fetch"),b.setAttribute("rel","prefetch"),b.setAttribute("href",origin+a.pathname+"/content.json"),document.head.appendChild(b)}}const appPromise=new Promise(function(a){document.addEventListener("DOMContentLoaded",()=>{a(loadContentAndInitializeApp())})});userInit.load(appPromise),"function"==typeof connect&&connect(function(a){appPromise.then(b=>{b.ports.fromJsPort.send({contentJson:a})})});const trigger_prefetch=b=>{const c=find_anchor(b.target);c&&c.href&&c.hasAttribute("elm-pages:prefetch")&&prefetchIfNeeded(c)};let mousemove_timeout;const handle_mousemove=a=>{clearTimeout(mousemove_timeout),mousemove_timeout=setTimeout(()=>{trigger_prefetch(a)},20)};addEventListener("touchstart",trigger_prefetch),addEventListener("mousemove",handle_mousemove);function find_anchor(a){for(;a&&"A"!==a.nodeName.toUpperCase();)a=a.parentNode;return a}
    </script>
    <title>Fixing Dan and Aydın's Pyright Error</title>
    <meta name="generator" content="elm-pages v2.1.10">
    <link rel="manifest" href="/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="canonical" href="https://angusjf.com/variance" />    <meta name="description" content="Fixing Dan and Aydın&apos;s Pyright Error" />    <meta property="og:image" content="https://angusjf.com/images/elm.webp" />    <meta property="og:image:secure_url" content="https://angusjf.com/images/elm.webp" />    <meta property="og:image:alt" content="The Elm logo" />    <meta property="og:title" content="Fixing Dan and Aydın&apos;s Pyright Error" />    <meta property="og:url" content="https://angusjf.com/variance" />    <meta property="og:description" content="Fixing Dan and Aydın&apos;s Pyright Error" />    <meta property="og:site_name" content="angusjf" />    <meta property="twitter:card" content="summary" />    <meta property="twitter:title" content="Fixing Dan and Aydın&apos;s Pyright Error" />    <meta property="twitter:description" content="Fixing Dan and Aydın&apos;s Pyright Error" />    <meta property="twitter:image" content="https://angusjf.com/images/elm.webp" />    <meta property="twitter:image:alt" content="The Elm logo" />    <meta property="og:type" content="article" />    <meta property="article:published_time" content="2021-10-25" />    <meta property="article:tag" content="elm" />    <meta property="article:tag" content="react" />    <meta property="article:tag" content="functional" />    <meta property="article:tag" content="javascript" />    <meta property="article:tag" content="typescript" />    <link rel="sitemap" type="application/xml" href="/sitemap.xml" />    <link rel="icon" type="image/png" href="https://angusjf.com/favicon.png" />    <link rel="icon" sizes="16x16" type="image/png" href="https://angusjf.com/favicon-16x16.png" />    <link rel="icon" sizes="32x32" type="image/png" href="https://angusjf.com/favicon-32x32.png" />    <link rel="apple-touch-icon" sizes="180x180" href="https://angusjf.com/apple-touch-icon.png" />    <meta name="msapplication-TileColor" content="#da532c" />    <meta name="theme-color" content="#ffffff" />
    <script id="__ELM_PAGES_DATA__" type="application/json">{"staticData":{"642666715":"{\"parsedFrontmatter\":{\"title\":\"Fixing Dan and Ayd\u0131n's Pyright Error\",\"img_url\":\"images/elm.webp\",\"img_alt\":\"The Elm logo\",\"date\":\"2021-10-25\",\"seo_description\":\"Fixing Dan and Ayd\u0131n's Pyright Error\",\"summary\":\"How Elm takes a novel approach to creating frontend applications, and what React developers can learn from it. Originally written for the [Theodo Blog](https://blog.theodo.com/2021/10/intro-to-elm-for-react-devs/), published in the [React Newsletter](https://reactnewsletter.com/issues/289).\",\"tags\":[\"elm\",\"react\",\"functional\",\"javascript\",\"typescript\"],\"hidden\":true},\"withoutFrontmatter\":\"# Fixing Dan and Ayd\u0131n's Pyright Error\\n\\n## Backstory\\n\\nA few months ago, my friends Dan and Ayd\u0131n showed me this strange bug in the project they were working on.\\n\\nThey were using Python with type annotations and Microsoft's Pylance/Pycheck type checker - here's the problematic snippet:\\n\\n```py\\nTODO\\n```\\n\\nWhen they ran the type checker on this code, they were presented with the following error:\\n\\n```py\\nTODO\\n```\\n\\nThis is the compiler's way of saying *__\\\"you can't pass a value of type `Dict[str, str]` into a function that expects `Dict[str, str | None]`\\\"__*\\n\\nThis seems wrong - surely any function that can handle a `Dict[str, str | None]` can handle a `Dict[str, str]` - in fact, a `Dict[str, str]` *is* a `Dict[str, str | None]`!\\n\\nSure enough, we can check that a `str` is a `str | None`:\\n\\n```py\\nname1: str = \\\"guido\\\"\\nname2: str | None = name1\\n```\\n\\nPycheck has no problems at all with this code.\\n\\nSurely (to be overly mathematical) if _`x` is a subtype of `y`_ then  _`Dict[a, x]` is a subtype of `Dict[a, y]`_.\\n\\nVery puzzling...\\n\\n## Rust for Rustaceans\\n\\nCrushingly, I could never fix Dan and Ayd\u0131n's type error. I just shrugged and said Microsoft probably never bothered to implement that rule.\\n\\nThen, three months later, I was reading (the fantastic) _Rust for Rustaceans_ (a book about the Rust programming language). On page ** they mention the concept of variance, an idea I'd never heard of before.\\n\\nIt turns out **variance** was the culprit all along - but first, let me introduce it with a tour of some popular programming languages.\\n\\n## Variance in TypeScript\\n\\nTypeScript has never sold itself as a fully type-safe solution, more of a glorified linter.\\nIt helps you catch **some** errors before you see them at runtime.\\n\\n_Consider the following (valid & compilable) TypeScript program._\\n\\n```ts\\ntype Status = \\\"OK\\\" | \\\"PENDING\\\" | \\\"INVALID\\\"\\n\\ntype ValidStatus = \\\"OK\\\" | \\\"PENDING\\\"\\n\\nconst orders: ValidStatus[] = [\\\"OK\\\", \\\"OK\\\", \\\"PENDING\\\"]\\n\\nconst add = (orders: Status[]) => {\\n    orders.push(\\\"INVALID\\\");\\n}\\n\\nadd(orders)\\n```\\n\\nNow orders has an invalid order in it - but it's type (`ValidStatus[]`) would tell you that's impossible!\\n\\nThe issue here is that we are *mutating the list* inside the add function.\\n\\nIf we treat `orders` as a `Status[]` in one place, and refer to it as a `ValidStatus[]` in another, we can cause all kinds of problems.\\n\\nThis can be avoided with the following, **immutable** version of the `add` function:\\n\\n```ts\\ntodo\\n```\\n\\nHowever:\\n- It's not ideomatic JavaScript\\n- It's far less efficient than using `push`\\n\\nIt's easy to get caught up evangilising immutable JavaScript as the solutions to these kinds of problems,\\nbut the performance impact can't be understated (see footnote 1 for an example).\\n\\n## Variance in Java\\n\\nJava's type system is stronger than TypeScript's, so let's recreate a similar example and see how it fares:\\n\\n```java\\nimport java.util.List;\\n\\nclass Status {}\\n\\nclass ValidStatus extends Status {}\\n\\nclass Main {\\n    public static void main(String[] args) {\\n        List<ValidStatus> orders;\\n        \\n        add(orders);\\n    }\\n    \\n    static void add(List<Status> orders) {\\n        // ...\\n    }\\n}\\n```\\n\\nJava gives the following error:\\n\\n```\\n\\n```\\n\\nPretty harsh! Java won't let us pass a `List<ValidStatus>` into a `List<Status>`, for fear we may mutate it.\\n\\nI suppose that's one way of solving the problem?\\n\\n## Variance in Rust\\n\\nRust's type system is the only one I've seen that **solves this problem properly**, that is to say it allows valid functions an d disallows dangerous ones.\\n\\n```rs\\nlet x: u32 = 1\\n```\\n\\nTo finally introduce the term, we can describe List\\n\\n## Variance in Pyright\\n\\nWith all of this context, let's look back at our original problem:\\n\\n```py\\n\\n```\\n\\nI finally see why Pyright is worried about this code.\\n\\nHow does it know we're not going to change the `***` dictionary inside the `***999*` function?\\n\\nHere Pyright is being just as strict as Java (although a little more cyptic).\\n\\n\\n\"}","3307685479":"[\"content/blog/variance.md\"]"},"is404":false,"path":"variance"}</script>
    </head>
    <body>
      <div data-url="" display="none"></div>
      <div class="wrapper"><span class="elm-css-style-wrapper" style="display: none;"><style></style></span><div class="link-back"><a href="/">angusjf</a></div><div class="blog"><h1>Fixing Dan and Aydın&#039;s Pyright Error</h1><h2>Backstory</h2><p>A few months ago, my friends Dan and Aydın showed me this strange bug in the project they were working on.</p><p>They were using Python with type annotations and Microsoft&#039;s Pylance/Pycheck type checker - here&#039;s the problematic snippet:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">TODO
</code></pre></div><p>When they ran the type checker on this code, they were presented with the following error:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">TODO
</code></pre></div><p>This is the compiler&#039;s way of saying <em><strong>&quot;you can&#039;t pass a value of type <code>Dict[str, str]</code> into a function that expects <code>Dict[str, str | None]</code>&quot;</strong></em></p><p>This seems wrong - surely any function that can handle a <code>Dict[str, str | None]</code> can handle a <code>Dict[str, str]</code> - in fact, a <code>Dict[str, str]</code> <em>is</em> a <code>Dict[str, str | None]</code>!</p><p>Sure enough, we can check that a <code>str</code> is a <code>str | None</code>:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">name1<span class="elmsh3 elmsh-js-k">:</span> str <span class="elmsh3 elmsh-js-k">=</span> <span class="elmsh2 elmsh-js-s">&quot;guido&quot;</span>
name2<span class="elmsh3 elmsh-js-k">:</span> str <span class="elmsh3 elmsh-js-k">|</span> None <span class="elmsh3 elmsh-js-k">=</span> name1
</code></pre></div><p>Pycheck has no problems at all with this code.</p><p>Surely (to be overly mathematical) if <em><code>x</code> is a subtype of <code>y</code></em> then  <em><code>Dict[a, x]</code> is a subtype of <code>Dict[a, y]</code></em>.</p><p>Very puzzling...</p><h2>Rust for Rustaceans</h2><p>Crushingly, I could never fix Dan and Aydın&#039;s type error. I just shrugged and said Microsoft probably never bothered to implement that rule.</p><p>Then, three months later, I was reading (the fantastic) <em>Rust for Rustaceans</em> (a book about the Rust programming language). On page ** they mention the concept of variance, an idea I&#039;d never heard of before.</p><p>It turns out <strong>variance</strong> was the culprit all along - but first, let me introduce it with a tour of some popular programming languages.</p><h2>Variance in TypeScript</h2><p>TypeScript has never sold itself as a fully type-safe solution, more of a glorified linter.
It helps you catch <strong>some</strong> errors before you see them at runtime.</p><p><em>Consider the following (valid &amp; compilable) TypeScript program.</em></p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">type Status <span class="elmsh3 elmsh-js-k">=</span> <span class="elmsh2 elmsh-js-s">&quot;OK&quot;</span> <span class="elmsh3 elmsh-js-k">|</span> <span class="elmsh2 elmsh-js-s">&quot;PENDING&quot;</span> <span class="elmsh3 elmsh-js-k">|</span> <span class="elmsh2 elmsh-js-s">&quot;INVALID&quot;</span>

type ValidStatus <span class="elmsh3 elmsh-js-k">=</span> <span class="elmsh2 elmsh-js-s">&quot;OK&quot;</span> <span class="elmsh3 elmsh-js-k">|</span> <span class="elmsh2 elmsh-js-s">&quot;PENDING&quot;</span>

<span class="elmsh4 elmsh-js-dk">const</span> orders<span class="elmsh3 elmsh-js-k">:</span> ValidStatus[] <span class="elmsh3 elmsh-js-k">=</span> [<span class="elmsh2 elmsh-js-s">&quot;OK&quot;</span>, <span class="elmsh2 elmsh-js-s">&quot;OK&quot;</span>, <span class="elmsh2 elmsh-js-s">&quot;PENDING&quot;</span>]

<span class="elmsh4 elmsh-js-dk">const</span> add <span class="elmsh3 elmsh-js-k">=</span> (orders<span class="elmsh3 elmsh-js-k">:</span> Status[]) <span class="elmsh3 elmsh-js-k">=&gt;</span> {
    orders<span class="elmsh3 elmsh-js-k">.</span><span class="elmsh4 elmsh-js-fe">push</span>(<span class="elmsh2 elmsh-js-s">&quot;INVALID&quot;</span>);
}

<span class="elmsh4 elmsh-js-fe">add</span>(orders)
</code></pre></div><p>Now orders has an invalid order in it - but it&#039;s type (<code>ValidStatus[]</code>) would tell you that&#039;s impossible!</p><p>The issue here is that we are <em>mutating the list</em> inside the add function.</p><p>If we treat <code>orders</code> as a <code>Status[]</code> in one place, and refer to it as a <code>ValidStatus[]</code> in another, we can cause all kinds of problems.</p><p>This can be avoided with the following, <strong>immutable</strong> version of the <code>add</code> function:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">todo
</code></pre></div><p>However:</p><ul><li>It&#039;s not ideomatic JavaScript</li><li>It&#039;s far less efficient than using <code>push</code></li></ul><p>It&#039;s easy to get caught up evangilising immutable JavaScript as the solutions to these kinds of problems,
but the performance impact can&#039;t be understated (see footnote 1 for an example).</p><h2>Variance in Java</h2><p>Java&#039;s type system is stronger than TypeScript&#039;s, so let&#039;s recreate a similar example and see how it fares:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh"><span class="elmsh3 elmsh-js-k">import</span> java<span class="elmsh3 elmsh-js-k">.</span>util<span class="elmsh3 elmsh-js-k">.</span>List;

<span class="elmsh4 elmsh-js-dk">class</span> <span class="elmsh5 elmsh-js-f">Status</span> {}

<span class="elmsh4 elmsh-js-dk">class</span> <span class="elmsh5 elmsh-js-f">ValidStatus</span> <span class="elmsh3 elmsh-js-k">extends</span> <span class="elmsh5 elmsh-js-ce">Status</span> {}

<span class="elmsh4 elmsh-js-dk">class</span> <span class="elmsh5 elmsh-js-f">Main</span> {
    <span class="elmsh3 elmsh-js-k">public</span> <span class="elmsh4 elmsh-js-dk">static</span> <span class="elmsh5 elmsh-js-f">void</span> <span class="elmsh5 elmsh-js-f">main</span>(<span class="elmsh7 elmsh-js-p">String[]</span> <span class="elmsh7 elmsh-js-p">args</span>) {
        List<span class="elmsh3 elmsh-js-k">&lt;</span>ValidStatus<span class="elmsh3 elmsh-js-k">&gt;</span> orders;
        
        <span class="elmsh4 elmsh-js-fe">add</span>(orders);
    }
    
    <span class="elmsh4 elmsh-js-dk">static</span> <span class="elmsh5 elmsh-js-f">void</span> <span class="elmsh5 elmsh-js-f">add</span>(<span class="elmsh7 elmsh-js-p">List&lt;Status&gt;</span> <span class="elmsh7 elmsh-js-p">orders</span>) {
        <span class="elmsh-comm">// ...</span>
    }
}
</code></pre></div><p>Java gives the following error:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">
</code></pre></div><p>Pretty harsh! Java won&#039;t let us pass a <code>List&lt;ValidStatus&gt;</code> into a <code>List&lt;Status&gt;</code>, for fear we may mutate it.</p><p>I suppose that&#039;s one way of solving the problem?</p><h2>Variance in Rust</h2><p>Rust&#039;s type system is the only one I&#039;ve seen that <strong>solves this problem properly</strong>, that is to say it allows valid functions an d disallows dangerous ones.</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh"><span class="elmsh4 elmsh-js-dk">let</span> x<span class="elmsh3 elmsh-js-k">:</span> u32 <span class="elmsh3 elmsh-js-k">=</span> <span class="elmsh1 elmsh-js-n">1</span>
</code></pre></div><p>To finally introduce the term, we can describe List</p><h2>Variance in Pyright</h2><p>With all of this context, let&#039;s look back at our original problem:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">
</code></pre></div><p>I finally see why Pyright is worried about this code.</p><p>How does it know we&#039;re not going to change the <code>***</code> dictionary inside the <code>***999*</code> function?</p><p>Here Pyright is being just as strict as Java (although a little more cyptic).</p></div></div>
    </body>
  </html>
  