<!DOCTYPE html>
  <html lang="en">
  <head>
    <link rel="stylesheet" href="/style.css">
    
    <link rel="preload" href="/elm.js" as="script">
    <link rel="modulepreload" href="/index.js">
    
    <script defer="defer" src="/elm.js" type="text/javascript"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <script type="module">
import userInit from"/index.js";
let prefetchedPages=[window.location.pathname],initialLocationHash=document.location.hash.replace(/^#/,"");function loadContentAndInitializeApp(){let a=window.location.pathname.replace(/(w)$/,"$1/");a.endsWith("/")||(a+="/");const b=Elm.TemplateModulesBeta.init({flags:{secrets:null,baseUrl:document.baseURI,isPrerendering:!1,isDevServer:!1,isElmDebugMode:!1,contentJson:JSON.parse(document.getElementById("__ELM_PAGES_DATA__").innerHTML),userFlags:userInit.flags()}});return b.ports.toJsPort.subscribe(()=>{loadNamedAnchor()}),b}function loadNamedAnchor(){if(""!==initialLocationHash){const a=document.querySelector(`[name=${initialLocationHash}]`);a&&a.scrollIntoView()}}function prefetchIfNeeded(a){if(a.host===window.location.host&&!prefetchedPages.includes(a.pathname)){prefetchedPages.push(a.pathname),console.log("Preloading...",a.pathname);const b=document.createElement("link");b.setAttribute("as","fetch"),b.setAttribute("rel","prefetch"),b.setAttribute("href",origin+a.pathname+"/content.json"),document.head.appendChild(b)}}const appPromise=new Promise(function(a){document.addEventListener("DOMContentLoaded",()=>{a(loadContentAndInitializeApp())})});userInit.load(appPromise),"function"==typeof connect&&connect(function(a){appPromise.then(b=>{b.ports.fromJsPort.send({contentJson:a})})});const trigger_prefetch=b=>{const c=find_anchor(b.target);c&&c.href&&c.hasAttribute("elm-pages:prefetch")&&prefetchIfNeeded(c)};let mousemove_timeout;const handle_mousemove=a=>{clearTimeout(mousemove_timeout),mousemove_timeout=setTimeout(()=>{trigger_prefetch(a)},20)};addEventListener("touchstart",trigger_prefetch),addEventListener("mousemove",handle_mousemove);function find_anchor(a){for(;a&&"A"!==a.nodeName.toUpperCase();)a=a.parentNode;return a}
    </script>
    <title>Fixing Dan and Aydın's Pyright Error</title>
    <meta name="generator" content="elm-pages v2.1.10">
    <link rel="manifest" href="/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="canonical" href="https://angusjf.com/variance" />    <meta name="description" content="How learning about Variance helped me fix a Pyright error." />    <meta property="og:image" content="https://angusjf.com/images/pyright.webp" />    <meta property="og:image:secure_url" content="https://angusjf.com/images/pyright.webp" />    <meta property="og:image:alt" content="The Pyright Logo on Fire" />    <meta property="og:title" content="Fixing Dan and Aydın&apos;s Pyright Error" />    <meta property="og:url" content="https://angusjf.com/variance" />    <meta property="og:description" content="How learning about Variance helped me fix a Pyright error." />    <meta property="og:site_name" content="angusjf" />    <meta property="twitter:card" content="summary" />    <meta property="twitter:title" content="Fixing Dan and Aydın&apos;s Pyright Error" />    <meta property="twitter:description" content="How learning about Variance helped me fix a Pyright error." />    <meta property="twitter:image" content="https://angusjf.com/images/pyright.webp" />    <meta property="twitter:image:alt" content="The Pyright Logo on Fire" />    <meta property="og:type" content="article" />    <meta property="article:published_time" content="2022-08-04" />    <meta property="article:tag" content="rust" />    <meta property="article:tag" content="variance" />    <meta property="article:tag" content="java" />    <meta property="article:tag" content="javascript" />    <meta property="article:tag" content="typescript" />    <link rel="sitemap" type="application/xml" href="/sitemap.xml" />    <link rel="icon" type="image/png" href="https://angusjf.com/favicon.png" />    <link rel="icon" sizes="16x16" type="image/png" href="https://angusjf.com/favicon-16x16.png" />    <link rel="icon" sizes="32x32" type="image/png" href="https://angusjf.com/favicon-32x32.png" />    <link rel="apple-touch-icon" sizes="180x180" href="https://angusjf.com/apple-touch-icon.png" />    <meta name="msapplication-TileColor" content="#da532c" />    <meta name="theme-color" content="#ffffff" />
    <script id="__ELM_PAGES_DATA__" type="application/json">{"staticData":{"642666715":"{\"parsedFrontmatter\":{\"title\":\"Fixing Dan and Ayd\u0131n's Pyright Error\",\"img_url\":\"images/pyright.webp\",\"img_alt\":\"The Pyright Logo on Fire\",\"date\":\"2022-08-04\",\"seo_description\":\"How learning about Variance helped me fix a Pyright error.\",\"summary\":\"How learning about Variance helped me fix a Pyright error.\",\"tags\":[\"rust\",\"variance\",\"java\",\"javascript\",\"typescript\"],\"hidden\":false},\"withoutFrontmatter\":\"\\n![Pyright](images/pyright.webp)\\n\\n# Fixing Dan and Ayd\u0131n's Pyright Error\\n\\n_Note: If you've never heard of Pylance/Pyright don't worry, it's just the TypeScript-ification of Python._\\n_If that doesn't mean anything to you, this might not be the blog post for you._\\n\\n## Backstory\\n\\nA few months ago, my friends Dan and Ayd\u0131n showed me this strange bug in the project they were working on.\\n\\nThey were using Python with type annotations and Microsoft's Pylance/Pyright type checker - here's (roughly) the problematic snippet:\\n\\n```python\\ndef send(data: Dict[str, str | None]):\\n    # ...\\n    \\nperson: Dict[str, str] = { \\\"name\\\": \\\"Guido\\\", \\\"dob\\\": \\\"1956-01-31\\\" }\\n\\nsend(person)\\n```\\n\\nWhen they ran the type checker on this code, they were presented with the following error:\\n\\n```python\\nerror: Argument of type \\\"dict[str, str]\\\" cannot be assigned to\\nparameter \\\"data\\\" of type \\\"Dict[str, str | None]\\\" in function \\\"send\\\"\\n  TypeVar \\\"_VT@dict\\\" is invariant\\n    Type \\\"str\\\" cannot be assigned to type \\\"str | None\\\"\\n      Type cannot be assigned to type \\\"None\\\" (reportGeneralTypeIssues)\\n```\\n\\nThis is the compiler's way of saying *__\\\"you can't pass a value of type `Dict[str, str]` into a function that expects `Dict[str, str | None]`\\\"__*\\n\\nThis seems wrong - surely any function that can handle a `Dict[str, str | None]` can handle a `Dict[str, str]` - in fact, a `Dict[str, str]` *is* a `Dict[str, str | None]`!\\n\\nSure enough, we can check that a `str` is a `str | None`:\\n\\n```python\\nname1: str = \\\"Guido\\\"\\nname2: str | None = name1\\n```\\n\\nPyright has no problems at all with this code.\\n\\nSurely (to be overly mathematical) if _`x` is a subtype of `y`_ then  _`Dict[a, x]` is a subtype of `Dict[a, y]`_.\\n\\nVery puzzling...\\n\\n## Rust for Rustaceans\\n\\nCrushingly, I could never fix Dan and Ayd\u0131n's type error. I just shrugged and said Microsoft probably never bothered to implement that rule for `Dict`s.\\n\\nThen, three months later, I was reading (the fantastic) _Rust for Rustaceans_ (a book about the Rust programming language). It introduced me to the concept of **Variance**, an idea I'd never heard of before.\\n\\n_(Maybe if I read the full Pyright error the first time I'd've noticed the \\\"`TypeVar \\\"_VT@dict\\\" is invariant`\\\" warning but alas)._\\n\\nIt turns out **Variance** was the culprit all along - but first, let me introduce it with a tour of some popular programming languages.\\n\\n## Insanely Liberal Variance in TypeScript\\n\\nTypeScript has never sold itself as a fully type-safe solution, more of a glorified linter.\\nIt helps you catch **some** errors before you see them at runtime.\\n\\n_Consider the following (valid & compilable) TypeScript program._\\\"\\n\\n```ts\\ntype Status = \\\"OK\\\" | \\\"PENDING\\\" | \\\"INVALID\\\"\\n\\ntype ValidStatus = \\\"OK\\\" | \\\"PENDING\\\"\\n\\nconst orders: ValidStatus[] = [\\\"OK\\\", \\\"OK\\\", \\\"PENDING\\\"]\\n\\nconst add = (orders: Status[]) => {\\n    orders.push(\\\"INVALID\\\");\\n}\\n\\nadd(orders)\\n```\\n\\nNow orders has an invalid order in it - but it's type (`ValidStatus[]`) would tell you that's impossible!\\n\\nThe issue here is that we are *mutating the list* inside the add function.\\n\\nIf we treat `orders` as a `Status[]` in one place, and refer to it as a `ValidStatus[]` in another, we can cause all kinds of problems.\\n\\nThis can be avoided with the following, **immutable** version of the `add` function:\\n\\n```ts\\n// ...\\n\\nconst add = (orders: readonly Status[]): readonly Status[] => {\\n    return [ ...orders,  \\\"INVALID\\\" ];\\n}\\n\\norders = add(orders)\\n```\\n\\nHowever:\\n- It's not idiomatic JavaScript\\n- It's far less efficient than using `push`\\n\\nIt's easy to get caught up evangelising immutable JavaScript as the solutions to these kinds of problems,\\nbut the performance impact can't be understated [(see here for an example)](/js-spread-operator).\\n\\n## Tyrannical Variance Rules in Java\\n\\nJava's type system is stronger than TypeScript's, so let's recreate a similar example and see how it fares:\\n\\nWe can defined the ValidStatus __*is-a*__ Status relation:\\n```java\\nclass Status {}\\n\\nclass ValidStatus extends Status {}\\n```\\n\\n```java\\nvoid add(List<Status> orders) {\\n    // ...\\n}\\n\\nList<ValidStatus> orders;\\n    \\nadd(orders);\\n```\\n\\nJava gives the following error:\\n\\n```java\\nerror: incompatible types: List<ValidStatus> cannot be converted to List<Status>\\n```\\n\\nPretty harsh! Java won't let us pass a `List<ValidStatus>` into a `List<Status>` function, for fear we may mutate it.\\n\\nI suppose that's one way of solving the problem?\\n\\n## Finally, Understanding Variance in Pyright\\n\\nWith all of this context, let's look back at our original problem:\\n\\n```python\\ndef send(data: Dict[str, str | None]):\\n    # ...\\n    \\nperson: Dict[str, str] = { \\\"name\\\": \\\"Guido\\\", \\\"dob\\\": \\\"1956-01-31\\\" }\\n\\nsend(person)\\n```\\n\\nI finally see why Pyright is worried about this code.\\n\\nHow does it know we're not going to change the `_person_` dictionary inside the `_send_` function?\\n\\nWe can't fault Pyright here, it's being as strict as it should be.\\nBut still, the type checker is holding us back. Maybe type systems are rubbish after all?\\n\\n## Rust Lets Me Down\\n\\nDespite **Rust**'s role in helping me understand this concept, it takes a Java-eqsue approach to subtyping inside lists.\\n\\nI was gutted to discover this - I felt Rust had all the right pieces to handle this perfectly but fall at the final hurdle.\\n\\nIt even differentiates between mutable and immutable references in the type system, so it could easily allow subtyping `T` in `&dyn Vec<T>` and forbid it for `&dyn mut Vec<T>`.\\n\\nAs described in the [Rustomicron](https://doc.rust-lang.org/nomicon/subtyping.html#variance), it's actually Rust's choice to abstain from object-orientation that makes this impossible. `&dyn T` isn't really a subtype of `&dyn U`, it's more \\\"castable\\\" to it.\\n\\n_(I still don't really see why we can't just cast Functors in the same way, if anyone does please let me know)_\\n\\n## Scala Saves the Day\\n\\nIf you're anything like me, at this stage you might be thinking, _\\\"Does **any** semi-popular modern programming language have robust variance rules?\\\"_\\n\\nScala does!\\n\\nScala is basically just a \\\"funtional Java\\\", and so it has first class support for both immutable data structures and subtyping.\\n\\nThis makes it perfect for our variance problem!\\n\\nIn Scala there are lots of different types of list, two examples are the immutable `List` and it's mutable brother `ListBuffer`.\\n\\nAgain we define the `ValidStatus` __*is-a*__ `Status` relation:\\n\\n```scala\\nclass Status {}\\n\\nclass ValidStatus extends Status {}\\n```\\n\\nSo `List` lets us do this:\\n\\n```scala\\ndef add(orders: List[Status]) {\\n    // we can't change list here, just look at it\\n}\\n\\nval orders = List[ValidStatus]()\\nadd(orders)\\n```\\n\\nWhile trying the same thing with `ListBuffer`...\\n\\n```java\\ndef add(orders: ListBuffer[Status]) {\\n    // we can change orders here!\\n    orders += new Status()\\n}\\n\\nval orders = ListBuffer[ValidStatus]()\\nadd(orders)\\n```\\nGives us the following error:\\n```java\\nerror: type mismatch;\\n found   : scala.collection.mutable.ListBuffer[ValidStatus]\\n required: scala.collection.mutable.ListBuffer[Status]\\nNote: ValidStatus <: Status, but class ListBuffer is invariant in type A.\\n```\\n\\nIt even describes ListBuffer as `invariant`, making Scala the winner in today's arbitrary programming language contest.\\n\\nThanks for reading!\\n\"}","3307685479":"[\"content/blog/variance.md\"]"},"is404":false,"path":"variance"}</script>
    </head>
    <body>
      <div data-url="" display="none"></div>
      <div class="wrapper"><span class="elm-css-style-wrapper" style="display: none;"><style></style></span><div class="link-back"><a href="/">angusjf</a></div><div class="blog"><p><div class="image-container"><img alt="Pyright" src="images/pyright.webp"></div></p><h1>Fixing Dan and Aydın&#039;s Pyright Error</h1><p><em>Note: If you&#039;ve never heard of Pylance/Pyright don&#039;t worry, it&#039;s just the TypeScript-ification of Python.</em>
<em>If that doesn&#039;t mean anything to you, this might not be the blog post for you.</em></p><h2>Backstory</h2><p>A few months ago, my friends Dan and Aydın showed me this strange bug in the project they were working on.</p><p>They were using Python with type annotations and Microsoft&#039;s Pylance/Pyright type checker - here&#039;s (roughly) the problematic snippet:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">def <span class="elmsh4 elmsh-js-fe">send</span>(data<span class="elmsh3 elmsh-js-k">:</span> Dict[str, str <span class="elmsh3 elmsh-js-k">|</span> None])<span class="elmsh3 elmsh-js-k">:</span>
    # <span class="elmsh3 elmsh-js-k">...</span>
    
person<span class="elmsh3 elmsh-js-k">:</span> Dict[str, str] <span class="elmsh3 elmsh-js-k">=</span> { <span class="elmsh2 elmsh-js-s">&quot;name&quot;</span><span class="elmsh3 elmsh-js-k">:</span> <span class="elmsh2 elmsh-js-s">&quot;Guido&quot;</span>, <span class="elmsh2 elmsh-js-s">&quot;dob&quot;</span><span class="elmsh3 elmsh-js-k">:</span> <span class="elmsh2 elmsh-js-s">&quot;1956-01-31&quot;</span> }

<span class="elmsh4 elmsh-js-fe">send</span>(person)
</code></pre></div><p>When they ran the type checker on this code, they were presented with the following error:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">error<span class="elmsh3 elmsh-js-k">:</span> Argument of type <span class="elmsh2 elmsh-js-s">&quot;dict[str, str]&quot;</span> cannot be assigned to
parameter <span class="elmsh2 elmsh-js-s">&quot;data&quot;</span> of type <span class="elmsh2 elmsh-js-s">&quot;Dict[str, str | None]&quot;</span> <span class="elmsh3 elmsh-js-k">in</span> <span class="elmsh4 elmsh-js-dk">function</span> <span class="elmsh2 elmsh-js-s">&quot;send&quot;</span>
  TypeVar <span class="elmsh2 elmsh-js-s">&quot;_VT@dict&quot;</span> is invariant
    Type <span class="elmsh2 elmsh-js-s">&quot;str&quot;</span> cannot be assigned to type <span class="elmsh2 elmsh-js-s">&quot;str | None&quot;</span>
      Type cannot be assigned to type <span class="elmsh2 elmsh-js-s">&quot;None&quot;</span> (reportGeneralTypeIssues)
</code></pre></div><p>This is the compiler&#039;s way of saying <em><strong>&quot;you can&#039;t pass a value of type <code>Dict[str, str]</code> into a function that expects <code>Dict[str, str | None]</code>&quot;</strong></em></p><p>This seems wrong - surely any function that can handle a <code>Dict[str, str | None]</code> can handle a <code>Dict[str, str]</code> - in fact, a <code>Dict[str, str]</code> <em>is</em> a <code>Dict[str, str | None]</code>!</p><p>Sure enough, we can check that a <code>str</code> is a <code>str | None</code>:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">name1<span class="elmsh3 elmsh-js-k">:</span> str <span class="elmsh3 elmsh-js-k">=</span> <span class="elmsh2 elmsh-js-s">&quot;Guido&quot;</span>
name2<span class="elmsh3 elmsh-js-k">:</span> str <span class="elmsh3 elmsh-js-k">|</span> None <span class="elmsh3 elmsh-js-k">=</span> name1
</code></pre></div><p>Pyright has no problems at all with this code.</p><p>Surely (to be overly mathematical) if <em><code>x</code> is a subtype of <code>y</code></em> then  <em><code>Dict[a, x]</code> is a subtype of <code>Dict[a, y]</code></em>.</p><p>Very puzzling...</p><h2>Rust for Rustaceans</h2><p>Crushingly, I could never fix Dan and Aydın&#039;s type error. I just shrugged and said Microsoft probably never bothered to implement that rule for <code>Dict</code>s.</p><p>Then, three months later, I was reading (the fantastic) <em>Rust for Rustaceans</em> (a book about the Rust programming language). It introduced me to the concept of <strong>Variance</strong>, an idea I&#039;d never heard of before.</p><p><em>(Maybe if I read the full Pyright error the first time I&#039;d&#039;ve noticed the &quot;<code>TypeVar &quot;_VT@dict&quot; is invariant</code>&quot; warning but alas).</em></p><p>It turns out <strong>Variance</strong> was the culprit all along - but first, let me introduce it with a tour of some popular programming languages.</p><h2>Insanely Liberal Variance in TypeScript</h2><p>TypeScript has never sold itself as a fully type-safe solution, more of a glorified linter.
It helps you catch <strong>some</strong> errors before you see them at runtime.</p><p><em>Consider the following (valid &amp; compilable) TypeScript program.</em>&quot;</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">type Status <span class="elmsh3 elmsh-js-k">=</span> <span class="elmsh2 elmsh-js-s">&quot;OK&quot;</span> <span class="elmsh3 elmsh-js-k">|</span> <span class="elmsh2 elmsh-js-s">&quot;PENDING&quot;</span> <span class="elmsh3 elmsh-js-k">|</span> <span class="elmsh2 elmsh-js-s">&quot;INVALID&quot;</span>

type ValidStatus <span class="elmsh3 elmsh-js-k">=</span> <span class="elmsh2 elmsh-js-s">&quot;OK&quot;</span> <span class="elmsh3 elmsh-js-k">|</span> <span class="elmsh2 elmsh-js-s">&quot;PENDING&quot;</span>

<span class="elmsh4 elmsh-js-dk">const</span> orders<span class="elmsh3 elmsh-js-k">:</span> ValidStatus[] <span class="elmsh3 elmsh-js-k">=</span> [<span class="elmsh2 elmsh-js-s">&quot;OK&quot;</span>, <span class="elmsh2 elmsh-js-s">&quot;OK&quot;</span>, <span class="elmsh2 elmsh-js-s">&quot;PENDING&quot;</span>]

<span class="elmsh4 elmsh-js-dk">const</span> add <span class="elmsh3 elmsh-js-k">=</span> (orders<span class="elmsh3 elmsh-js-k">:</span> Status[]) <span class="elmsh3 elmsh-js-k">=&gt;</span> {
    orders<span class="elmsh3 elmsh-js-k">.</span><span class="elmsh4 elmsh-js-fe">push</span>(<span class="elmsh2 elmsh-js-s">&quot;INVALID&quot;</span>);
}

<span class="elmsh4 elmsh-js-fe">add</span>(orders)
</code></pre></div><p>Now orders has an invalid order in it - but it&#039;s type (<code>ValidStatus[]</code>) would tell you that&#039;s impossible!</p><p>The issue here is that we are <em>mutating the list</em> inside the add function.</p><p>If we treat <code>orders</code> as a <code>Status[]</code> in one place, and refer to it as a <code>ValidStatus[]</code> in another, we can cause all kinds of problems.</p><p>This can be avoided with the following, <strong>immutable</strong> version of the <code>add</code> function:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh"><span class="elmsh-comm">// ...</span>

<span class="elmsh4 elmsh-js-dk">const</span> add <span class="elmsh3 elmsh-js-k">=</span> (orders<span class="elmsh3 elmsh-js-k">:</span> readonly Status[])<span class="elmsh3 elmsh-js-k">:</span> readonly Status[] <span class="elmsh3 elmsh-js-k">=&gt;</span> {
    <span class="elmsh3 elmsh-js-k">return</span> [ <span class="elmsh3 elmsh-js-k">...</span>orders,  <span class="elmsh2 elmsh-js-s">&quot;INVALID&quot;</span> ];
}

orders <span class="elmsh3 elmsh-js-k">=</span> <span class="elmsh4 elmsh-js-fe">add</span>(orders)
</code></pre></div><p>However:</p><ul><li>It&#039;s not idiomatic JavaScript</li><li>It&#039;s far less efficient than using <code>push</code></li></ul><p>It&#039;s easy to get caught up evangelising immutable JavaScript as the solutions to these kinds of problems,
but the performance impact can&#039;t be understated <a href="/js-spread-operator">(see here for an example)</a>.</p><h2>Tyrannical Variance Rules in Java</h2><p>Java&#039;s type system is stronger than TypeScript&#039;s, so let&#039;s recreate a similar example and see how it fares:</p><p>We can defined the ValidStatus <strong><em>is-a</em></strong> Status relation:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh"><span class="elmsh4 elmsh-js-dk">class</span> <span class="elmsh5 elmsh-js-f">Status</span> {}

<span class="elmsh4 elmsh-js-dk">class</span> <span class="elmsh5 elmsh-js-f">ValidStatus</span> <span class="elmsh3 elmsh-js-k">extends</span> <span class="elmsh5 elmsh-js-ce">Status</span> {}
</code></pre></div><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh"><span class="elmsh3 elmsh-js-k">void</span> <span class="elmsh4 elmsh-js-fe">add</span>(List<span class="elmsh3 elmsh-js-k">&lt;</span>Status<span class="elmsh3 elmsh-js-k">&gt;</span> orders) {
    <span class="elmsh-comm">// ...</span>
}

List<span class="elmsh3 elmsh-js-k">&lt;</span>ValidStatus<span class="elmsh3 elmsh-js-k">&gt;</span> orders;
    
<span class="elmsh4 elmsh-js-fe">add</span>(orders);
</code></pre></div><p>Java gives the following error:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">error<span class="elmsh3 elmsh-js-k">:</span> incompatible types<span class="elmsh3 elmsh-js-k">:</span> List<span class="elmsh3 elmsh-js-k">&lt;</span>ValidStatus<span class="elmsh3 elmsh-js-k">&gt;</span> cannot be converted to List<span class="elmsh3 elmsh-js-k">&lt;</span>Status<span class="elmsh3 elmsh-js-k">&gt;</span>
</code></pre></div><p>Pretty harsh! Java won&#039;t let us pass a <code>List&lt;ValidStatus&gt;</code> into a <code>List&lt;Status&gt;</code> function, for fear we may mutate it.</p><p>I suppose that&#039;s one way of solving the problem?</p><h2>Finally, Understanding Variance in Pyright</h2><p>With all of this context, let&#039;s look back at our original problem:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">def <span class="elmsh4 elmsh-js-fe">send</span>(data<span class="elmsh3 elmsh-js-k">:</span> Dict[str, str <span class="elmsh3 elmsh-js-k">|</span> None])<span class="elmsh3 elmsh-js-k">:</span>
    # <span class="elmsh3 elmsh-js-k">...</span>
    
person<span class="elmsh3 elmsh-js-k">:</span> Dict[str, str] <span class="elmsh3 elmsh-js-k">=</span> { <span class="elmsh2 elmsh-js-s">&quot;name&quot;</span><span class="elmsh3 elmsh-js-k">:</span> <span class="elmsh2 elmsh-js-s">&quot;Guido&quot;</span>, <span class="elmsh2 elmsh-js-s">&quot;dob&quot;</span><span class="elmsh3 elmsh-js-k">:</span> <span class="elmsh2 elmsh-js-s">&quot;1956-01-31&quot;</span> }

<span class="elmsh4 elmsh-js-fe">send</span>(person)
</code></pre></div><p>I finally see why Pyright is worried about this code.</p><p>How does it know we&#039;re not going to change the <code>_person_</code> dictionary inside the <code>_send_</code> function?</p><p>We can&#039;t fault Pyright here, it&#039;s being as strict as it should be.
But still, the type checker is holding us back. Maybe type systems are rubbish after all?</p><h2>Rust Lets Me Down</h2><p>Despite <strong>Rust</strong>&#039;s role in helping me understand this concept, it takes a Java-eqsue approach to subtyping inside lists.</p><p>I was gutted to discover this - I felt Rust had all the right pieces to handle this perfectly but fall at the final hurdle.</p><p>It even differentiates between mutable and immutable references in the type system, so it could easily allow subtyping <code>T</code> in <code>&amp;dyn Vec&lt;T&gt;</code> and forbid it for <code>&amp;dyn mut Vec&lt;T&gt;</code>.</p><p>As described in the <a href="https://doc.rust-lang.org/nomicon/subtyping.html#variance">Rustomicron</a>, it&#039;s actually Rust&#039;s choice to abstain from object-orientation that makes this impossible. <code>&amp;dyn T</code> isn&#039;t really a subtype of <code>&amp;dyn U</code>, it&#039;s more &quot;castable&quot; to it.</p><p><em>(I still don&#039;t really see why we can&#039;t just cast Functors in the same way, if anyone does please let me know)</em></p><h2>Scala Saves the Day</h2><p>If you&#039;re anything like me, at this stage you might be thinking, <em>&quot;Does <strong>any</strong> semi-popular modern programming language have robust variance rules?&quot;</em></p><p>Scala does!</p><p>Scala is basically just a &quot;funtional Java&quot;, and so it has first class support for both immutable data structures and subtyping.</p><p>This makes it perfect for our variance problem!</p><p>In Scala there are lots of different types of list, two examples are the immutable <code>List</code> and it&#039;s mutable brother <code>ListBuffer</code>.</p><p>Again we define the <code>ValidStatus</code> <strong><em>is-a</em></strong> <code>Status</code> relation:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh"><span class="elmsh4 elmsh-js-dk">class</span> <span class="elmsh5 elmsh-js-f">Status</span> {}

<span class="elmsh4 elmsh-js-dk">class</span> <span class="elmsh5 elmsh-js-f">ValidStatus</span> <span class="elmsh3 elmsh-js-k">extends</span> <span class="elmsh5 elmsh-js-ce">Status</span> {}
</code></pre></div><p>So <code>List</code> lets us do this:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">def <span class="elmsh4 elmsh-js-fe">add</span>(orders<span class="elmsh3 elmsh-js-k">:</span> List[Status]) {
    <span class="elmsh-comm">// we can&#039;t change list here, just look at it</span>
}

val orders <span class="elmsh3 elmsh-js-k">=</span> List[ValidStatus]()
<span class="elmsh4 elmsh-js-fe">add</span>(orders)
</code></pre></div><p>While trying the same thing with <code>ListBuffer</code>...</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">def <span class="elmsh4 elmsh-js-fe">add</span>(orders<span class="elmsh3 elmsh-js-k">:</span> ListBuffer[Status]) {
    <span class="elmsh-comm">// we can change orders here!</span>
    orders <span class="elmsh3 elmsh-js-k">+=</span> <span class="elmsh3 elmsh-js-k">new</span> <span class="elmsh4 elmsh-js-fe">Status</span>()
}

val orders <span class="elmsh3 elmsh-js-k">=</span> ListBuffer[ValidStatus]()
<span class="elmsh4 elmsh-js-fe">add</span>(orders)
</code></pre></div><p>Gives us the following error:</p><div><style>.elmsh {color: #24292e;background: #ffffff;}.elmsh-hl {background: #fffbdd;}.elmsh-add {background: #eaffea;}.elmsh-del {background: #ffecec;}.elmsh-comm {color: #969896;}.elmsh1 {color: #005cc5;}.elmsh2 {color: #df5000;}.elmsh3 {color: #d73a49;}.elmsh4 {color: #0086b3;}.elmsh5 {color: #63a35c;}.elmsh6 {color: #005cc5;}.elmsh7 {color: #795da3;}</style><pre class="elmsh"><code class="elmsh">error<span class="elmsh3 elmsh-js-k">:</span> type mismatch;
 found   <span class="elmsh3 elmsh-js-k">:</span> scala<span class="elmsh3 elmsh-js-k">.</span>collection<span class="elmsh3 elmsh-js-k">.</span>mutable<span class="elmsh3 elmsh-js-k">.</span>ListBuffer[ValidStatus]
 required<span class="elmsh3 elmsh-js-k">:</span> scala<span class="elmsh3 elmsh-js-k">.</span>collection<span class="elmsh3 elmsh-js-k">.</span>mutable<span class="elmsh3 elmsh-js-k">.</span>ListBuffer[Status]
Note<span class="elmsh3 elmsh-js-k">:</span> ValidStatus <span class="elmsh3 elmsh-js-k">&lt;:</span> Status, but <span class="elmsh4 elmsh-js-dk">class</span> <span class="elmsh5 elmsh-js-f">ListBuffer</span> <span class="elmsh5 elmsh-js-f">is</span> <span class="elmsh5 elmsh-js-f">invariant</span> <span class="elmsh5 elmsh-js-f">in</span> <span class="elmsh5 elmsh-js-f">type</span> <span class="elmsh5 elmsh-js-f">A</span><span class="elmsh3 elmsh-js-k">.</span>
</code></pre></div><p>It even describes ListBuffer as <code>invariant</code>, making Scala the winner in today&#039;s arbitrary programming language contest.</p><p>Thanks for reading!</p></div></div>
    </body>
  </html>
  